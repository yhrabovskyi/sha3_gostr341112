#include "keccakH.h"

// ////////////////////////////////////////////////////////////////////////////
void KeccakF(void)
{
  uint8_t iR;
  for (iR = 0; iR < NROUNDS; iR++)
  {
    theta();
    rho();
    pi();
    chi();
    iota(iR);
  }
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void theta(void)
{
  uint32_t C[5*DIV];
  uint32_t c_temp[5];
  uint32_t *p;
  uint32_t low, high;
  uint8_t x, y, i;
  
  // Обчислюємо C
  for (x = 0; x < 5; x++)
  {
    p = state + (x << 1);
    low  = *p;
    high = *(p + 1);
    for (y = 1; y < 5; y++)
    {
      p += 10;
      low  ^= *p;
      high ^= *(p+1);
    }
    *(C + (x << 1)    ) = low;
    *(C + (x << 1) + 1) = high;
  }
  
  // Обчислюємо новий стан
  c_temp[0] = ROL32(*(C + 3), 1) ^ *(C + 8);
  c_temp[1] = ROL32(*(C + 5), 1) ^ *(C    );
  c_temp[2] = ROL32(*(C + 7), 1) ^ *(C + 2);
  c_temp[3] = ROL32(*(C + 9), 1) ^ *(C + 4);
  c_temp[4] = ROL32(*(C + 1), 1) ^ *(C + 6);
  
  for (i = 0; i < 2; i++)
  {
    if (i)
    {
      c_temp[0] = *(C + 2) ^ *(C + 9);
      c_temp[1] = *(C + 4) ^ *(C + 1);
      c_temp[2] = *(C + 6) ^ *(C + 3);
      c_temp[3] = *(C + 8) ^ *(C + 5);
      c_temp[4] = *(C    ) ^ *(C + 7);
    }
    
    for (x = 0; x < 5; x++)
    {
      p = state + i + (x << 1);
      *p        ^= c_temp[x];
      *(p + 10) ^= c_temp[x];
      *(p + 20) ^= c_temp[x];
      *(p + 30) ^= c_temp[x];
      *(p + 40) ^= c_temp[x];
    }
  }
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void rho(void)
{
  uint32_t i;
  uint32_t offset, mask;
  
  uint32_t temp_word;
  uint32_t *p_state;
  
  extern uint8_t rho_offset[];
  
  mask = 0x01;
  p_state = state + 2;
  
  for (i = 1; i < LANES; i++)
  {
    offset = rho_offset[i];
    
    if (offset & mask)
    {
      offset >>= DIV_OFFSET;
      temp_word = *p_state;
      *p_state = ROL32(*(p_state + 1), offset + 1);
      p_state++;
      *p_state = ROL32(temp_word, offset);
    }
    else
    {
      offset >>= DIV_OFFSET;
      *p_state = ROL32(*p_state, offset);
      p_state++;
      *p_state = ROL32(*p_state, offset);
    }
    
    p_state++;
  }
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void pi(void)
{
  uint8_t i, k;
  uint32_t temp_0, temp_1, temp_2, temp_3;
  extern uint8_t piTranslation[];
  
  temp_0 = state[20];
  temp_1 = state[21];
  state[20] = state[2];
  state[21] = state[3];
  
  k = 10;
  for (i = 2; i < (LANES - 1); i += 2)
  {
    temp_2 = state[DIV*piTranslation[k]];
    temp_3 = state[DIV*piTranslation[k]+1];
    
    state[DIV*piTranslation[k]] = temp_0;
    state[DIV*piTranslation[k]+1] = temp_1;
    
    k = piTranslation[k];
    
    temp_0 = state[DIV*piTranslation[k]];
    temp_1 = state[DIV*piTranslation[k]+1];
    
    state[DIV*piTranslation[k]] = temp_2;
    state[DIV*piTranslation[k]+1] = temp_3;
    
    k = piTranslation[k];
  }
  
  state[2] = temp_0;
  state[3] = temp_1;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void chi(void)
{
  uint8_t i, j; // Лічильники для циклів
  uint32_t word_0, word_1, word_2, word_3, word_4; // Половини смуг
  uint32_t *p_state; // Покажчик стану
  
  p_state = state;
  
  for (i = 0; i < 5; i++)
  {
    // Пробігаємо першу половину смуг, а потім другу
    for (j = 0; j < 2; j++)
    {
      word_0 = *p_state;
      word_1 = *(p_state + 2);
      word_2 = *(p_state + 4);
      word_3 = *(p_state + 6);
      word_4 = *(p_state + 8);
      
      *(p_state    ) = word_0 ^ (~word_1 & word_2);
      *(p_state + 2) = word_1 ^ (~word_2 & word_3);
      *(p_state + 4) = word_2 ^ (~word_3 & word_4);
      *(p_state + 6) = word_3 ^ (~word_4 & word_0);
      *(p_state + 8) = word_4 ^ (~word_0 & word_1);
      
      p_state++; // Переходимо на другу половину
    }
    
    p_state += 8; // Переходимо на наступний стовпець
  }
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void iota(uint8_t round)
{
  extern uint32_t RC[];

  state[0] ^= RC[round << DIV_OFFSET];
  state[1] ^= RC[(round << DIV_OFFSET) + 1];
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
uint8_t piTranslation[] = 
{
   0, 10, 20,  5, 15,
  16,  1, 11, 21,  6,
   7, 17,  2, 12, 22,
  23,  8, 18,  3, 13,
  14, 24,  9, 19,  4
};
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
uint8_t rho_offset[] = 
{
   0,  1, 62, 28, 27,
  36, 44,  6, 55, 20,
   3, 10, 43, 25, 39,
  41, 45, 15, 21,  8,
  18,  2, 61, 56, 14
};
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
uint32_t RC[] = 
{
  0x00000001, 0x00000000,
  0x00000000, 0x00000089,
  0x00000000, 0x8000008B,
  0x00000000, 0x80008080,
  0x00000001, 0x0000008B,
  0x00000001, 0x00008000,
  0x00000001, 0x80008088,
  0x00000001, 0x80000082,
  0x00000000, 0x0000000B,
  0x00000000, 0x0000000A,
  0x00000001, 0x00008082,
  0x00000000, 0x00008003,
  0x00000001, 0x0000808B,
  0x00000001, 0x8000000B,
  0x00000001, 0x8000008A,
  0x00000001, 0x80000081,
  0x00000000, 0x80000081,
  0x00000000, 0x80000008,
  0x00000000, 0x00000083,
  0x00000000, 0x80008003,
  0x00000001, 0x80008088,
  0x00000000, 0x80000088,
  0x00000001, 0x00008000,
  0x00000000, 0x80008082
};
// ////////////////////////////////////////////////////////////////////////////
